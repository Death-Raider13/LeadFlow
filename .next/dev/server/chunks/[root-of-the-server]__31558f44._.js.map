{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/LeadFlow/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from \"@supabase/ssr\"\nimport { cookies } from \"next/headers\"\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!, {\n    cookies: {\n      getAll() {\n        return cookieStore.getAll()\n      },\n      setAll(cookiesToSet) {\n        try {\n          cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options))\n        } catch {\n          // The \"setAll\" method was called from a Server Component.\n        }\n      },\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,sUAAoF;QAC3G,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAAK,YAAY,GAAG,CAAC,MAAM,OAAO;gBAClF,EAAE,OAAM;gBACN,0DAA0D;gBAC5D;YACF;QACF;IACF;AACF"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/LeadFlow/lib/encryption.ts"],"sourcesContent":["import crypto from \"crypto\"\r\n\r\n// Master key must be a 32-byte key, provided as base64 in env CREDENTIALS_ENCRYPTION_KEY\r\nconst MASTER_KEY_ENV = process.env.CREDENTIALS_ENCRYPTION_KEY\r\n\r\nif (!MASTER_KEY_ENV) {\r\n  // We intentionally do not throw at import time to avoid breaking build if env is missing.\r\n  // The API routes that depend on this should validate and throw a clear error instead.\r\n  console.warn(\"CREDENTIALS_ENCRYPTION_KEY is not set. Encryption helpers will fail until it is configured.\")\r\n}\r\n\r\nfunction getMasterKey(): Buffer {\r\n  if (!MASTER_KEY_ENV) {\r\n    throw new Error(\"CREDENTIALS_ENCRYPTION_KEY is not configured\")\r\n  }\r\n  const key = Buffer.from(MASTER_KEY_ENV, \"base64\")\r\n  if (key.length !== 32) {\r\n    throw new Error(\"CREDENTIALS_ENCRYPTION_KEY must be a 32-byte key encoded in base64\")\r\n  }\r\n  return key\r\n}\r\n\r\nexport function generateRandomKey(): string {\r\n  // 32 random bytes, returned as base64\r\n  return crypto.randomBytes(32).toString(\"base64\")\r\n}\r\n\r\nexport interface EncryptedPayload {\r\n  ciphertext: string\r\n  iv: string\r\n  authTag: string\r\n}\r\n\r\nexport function encryptWithKey(keyBase64: string, plaintext: string): EncryptedPayload {\r\n  const key = Buffer.from(keyBase64, \"base64\")\r\n  if (key.length !== 32) {\r\n    throw new Error(\"Encryption key must be 32 bytes (base64-encoded)\")\r\n  }\r\n\r\n  const iv = crypto.randomBytes(12) // recommended IV size for GCM\r\n  const cipher = crypto.createCipheriv(\"aes-256-gcm\", key, iv)\r\n\r\n  const encrypted = Buffer.concat([cipher.update(plaintext, \"utf8\"), cipher.final()])\r\n  const authTag = cipher.getAuthTag()\r\n\r\n  return {\r\n    ciphertext: encrypted.toString(\"base64\"),\r\n    iv: iv.toString(\"base64\"),\r\n    authTag: authTag.toString(\"base64\"),\r\n  }\r\n}\r\n\r\nexport function decryptWithKey(keyBase64: string, payload: EncryptedPayload): string {\r\n  const key = Buffer.from(keyBase64, \"base64\")\r\n  if (key.length !== 32) {\r\n    throw new Error(\"Encryption key must be 32 bytes (base64-encoded)\")\r\n  }\r\n\r\n  const iv = Buffer.from(payload.iv, \"base64\")\r\n  const authTag = Buffer.from(payload.authTag, \"base64\")\r\n  const ciphertext = Buffer.from(payload.ciphertext, \"base64\")\r\n\r\n  const decipher = crypto.createDecipheriv(\"aes-256-gcm\", key, iv)\r\n  decipher.setAuthTag(authTag)\r\n\r\n  const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()])\r\n  return decrypted.toString(\"utf8\")\r\n}\r\n\r\n// Wrap/unwrap per-user data key using master key\r\n\r\nexport function wrapUserKey(userKeyBase64: string): EncryptedPayload {\r\n  const masterKey = getMasterKey()\r\n  const iv = crypto.randomBytes(12)\r\n  const cipher = crypto.createCipheriv(\"aes-256-gcm\", masterKey, iv)\r\n\r\n  const encrypted = Buffer.concat([cipher.update(userKeyBase64, \"utf8\"), cipher.final()])\r\n  const authTag = cipher.getAuthTag()\r\n\r\n  return {\r\n    ciphertext: encrypted.toString(\"base64\"),\r\n    iv: iv.toString(\"base64\"),\r\n    authTag: authTag.toString(\"base64\"),\r\n  }\r\n}\r\n\r\nexport function unwrapUserKey(payload: EncryptedPayload): string {\r\n  const masterKey = getMasterKey()\r\n\r\n  const iv = Buffer.from(payload.iv, \"base64\")\r\n  const authTag = Buffer.from(payload.authTag, \"base64\")\r\n  const ciphertext = Buffer.from(payload.ciphertext, \"base64\")\r\n\r\n  const decipher = crypto.createDecipheriv(\"aes-256-gcm\", masterKey, iv)\r\n  decipher.setAuthTag(authTag)\r\n\r\n  const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()])\r\n  return decrypted.toString(\"utf8\")\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEA,yFAAyF;AACzF,MAAM,iBAAiB,QAAQ,GAAG,CAAC,0BAA0B;AAE7D,IAAI,CAAC,gBAAgB;IACnB,0FAA0F;IAC1F,sFAAsF;IACtF,QAAQ,IAAI,CAAC;AACf;AAEA,SAAS;IACP,IAAI,CAAC,gBAAgB;QACnB,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO,IAAI,CAAC,gBAAgB;IACxC,IAAI,IAAI,MAAM,KAAK,IAAI;QACrB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEO,SAAS;IACd,sCAAsC;IACtC,OAAO,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;AACzC;AAQO,SAAS,eAAe,SAAiB,EAAE,SAAiB;IACjE,MAAM,MAAM,OAAO,IAAI,CAAC,WAAW;IACnC,IAAI,IAAI,MAAM,KAAK,IAAI;QACrB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,gHAAM,CAAC,WAAW,CAAC,IAAI,8BAA8B;;IAChE,MAAM,SAAS,gHAAM,CAAC,cAAc,CAAC,eAAe,KAAK;IAEzD,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,OAAO,MAAM,CAAC,WAAW;QAAS,OAAO,KAAK;KAAG;IAClF,MAAM,UAAU,OAAO,UAAU;IAEjC,OAAO;QACL,YAAY,UAAU,QAAQ,CAAC;QAC/B,IAAI,GAAG,QAAQ,CAAC;QAChB,SAAS,QAAQ,QAAQ,CAAC;IAC5B;AACF;AAEO,SAAS,eAAe,SAAiB,EAAE,OAAyB;IACzE,MAAM,MAAM,OAAO,IAAI,CAAC,WAAW;IACnC,IAAI,IAAI,MAAM,KAAK,IAAI;QACrB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,OAAO,IAAI,CAAC,QAAQ,EAAE,EAAE;IACnC,MAAM,UAAU,OAAO,IAAI,CAAC,QAAQ,OAAO,EAAE;IAC7C,MAAM,aAAa,OAAO,IAAI,CAAC,QAAQ,UAAU,EAAE;IAEnD,MAAM,WAAW,gHAAM,CAAC,gBAAgB,CAAC,eAAe,KAAK;IAC7D,SAAS,UAAU,CAAC;IAEpB,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,SAAS,MAAM,CAAC;QAAa,SAAS,KAAK;KAAG;IAC/E,OAAO,UAAU,QAAQ,CAAC;AAC5B;AAIO,SAAS,YAAY,aAAqB;IAC/C,MAAM,YAAY;IAClB,MAAM,KAAK,gHAAM,CAAC,WAAW,CAAC;IAC9B,MAAM,SAAS,gHAAM,CAAC,cAAc,CAAC,eAAe,WAAW;IAE/D,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,OAAO,MAAM,CAAC,eAAe;QAAS,OAAO,KAAK;KAAG;IACtF,MAAM,UAAU,OAAO,UAAU;IAEjC,OAAO;QACL,YAAY,UAAU,QAAQ,CAAC;QAC/B,IAAI,GAAG,QAAQ,CAAC;QAChB,SAAS,QAAQ,QAAQ,CAAC;IAC5B;AACF;AAEO,SAAS,cAAc,OAAyB;IACrD,MAAM,YAAY;IAElB,MAAM,KAAK,OAAO,IAAI,CAAC,QAAQ,EAAE,EAAE;IACnC,MAAM,UAAU,OAAO,IAAI,CAAC,QAAQ,OAAO,EAAE;IAC7C,MAAM,aAAa,OAAO,IAAI,CAAC,QAAQ,UAAU,EAAE;IAEnD,MAAM,WAAW,gHAAM,CAAC,gBAAgB,CAAC,eAAe,WAAW;IACnE,SAAS,UAAU,CAAC;IAEpB,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,SAAS,MAAM,CAAC;QAAa,SAAS,KAAK;KAAG;IAC/E,OAAO,UAAU,QAAQ,CAAC;AAC5B"}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/LeadFlow/app/api/integrations/credentials/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\r\nimport { createClient } from \"@/lib/supabase/server\"\r\nimport { decryptWithKey, encryptWithKey, generateRandomKey, unwrapUserKey, wrapUserKey } from \"@/lib/encryption\"\r\n\r\ninterface CredentialsBody {\r\n  ultramsgInstanceId?: string\r\n  ultramsgToken?: string\r\n  gmailAddress?: string\r\n  gmailAppPassword?: string\r\n}\r\n\r\nexport async function GET() {\r\n  try {\r\n    const supabase = await createClient()\r\n    const {\r\n      data: { user },\r\n    } = await supabase.auth.getUser()\r\n\r\n    if (!user) {\r\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"user_integrations\")\r\n      .select(\"ultramsg_instance_enc, ultramsg_token_enc, gmail_address_enc, gmail_app_password_enc\")\r\n      .eq(\"user_id\", user.id)\r\n      .single()\r\n\r\n    if (error && error.code !== \"PGRST116\") {\r\n      console.error(\"Error fetching user_integrations:\", error)\r\n      return NextResponse.json({ error: \"Failed to load integration status\" }, { status: 500 })\r\n    }\r\n\r\n    const hasWhatsApp = !!(data && data.ultramsg_instance_enc && data.ultramsg_token_enc)\r\n    const hasGmail = !!(data && data.gmail_address_enc && data.gmail_app_password_enc)\r\n\r\n    return NextResponse.json({ hasWhatsApp, hasGmail })\r\n  } catch (err: any) {\r\n    console.error(\"Integrations GET error:\", err)\r\n    return NextResponse.json({ error: \"Unexpected error\" }, { status: 500 })\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = (await request.json()) as CredentialsBody\r\n    const { ultramsgInstanceId, ultramsgToken, gmailAddress, gmailAppPassword } = body\r\n\r\n    if (!ultramsgInstanceId && !ultramsgToken && !gmailAddress && !gmailAppPassword) {\r\n      return NextResponse.json({ error: \"No credentials provided\" }, { status: 400 })\r\n    }\r\n\r\n    const supabase = await createClient()\r\n    const {\r\n      data: { user },\r\n    } = await supabase.auth.getUser()\r\n\r\n    if (!user) {\r\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\r\n    }\r\n\r\n    const { data: existing } = await supabase\r\n      .from(\"user_integrations\")\r\n      .select(\"user_key_enc, ultramsg_instance_enc, ultramsg_token_enc, gmail_address_enc, gmail_app_password_enc\")\r\n      .eq(\"user_id\", user.id)\r\n      .maybeSingle()\r\n\r\n    let userKeyBase64: string\r\n    let wrappedUserKeyPayload: any\r\n\r\n    if (existing && existing.user_key_enc) {\r\n      userKeyBase64 = unwrapUserKey(existing.user_key_enc)\r\n      wrappedUserKeyPayload = existing.user_key_enc\r\n    } else {\r\n      userKeyBase64 = generateRandomKey()\r\n      wrappedUserKeyPayload = wrapUserKey(userKeyBase64)\r\n    }\r\n\r\n    const payload: any = {\r\n      user_id: user.id,\r\n      user_key_enc: wrappedUserKeyPayload,\r\n      updated_at: new Date().toISOString(),\r\n    }\r\n\r\n    if (ultramsgInstanceId) {\r\n      payload.ultramsg_instance_enc = encryptWithKey(userKeyBase64, ultramsgInstanceId)\r\n    }\r\n    if (ultramsgToken) {\r\n      payload.ultramsg_token_enc = encryptWithKey(userKeyBase64, ultramsgToken)\r\n    }\r\n    if (gmailAddress) {\r\n      payload.gmail_address_enc = encryptWithKey(userKeyBase64, gmailAddress)\r\n    }\r\n    if (gmailAppPassword) {\r\n      payload.gmail_app_password_enc = encryptWithKey(userKeyBase64, gmailAppPassword)\r\n    }\r\n\r\n    if (!existing) {\r\n      payload.created_at = new Date().toISOString()\r\n    }\r\n\r\n    const { error } = await supabase.from(\"user_integrations\").upsert(payload, { onConflict: \"user_id\" })\r\n\r\n    if (error) {\r\n      console.error(\"Error saving user_integrations:\", error)\r\n      return NextResponse.json({ error: \"Failed to save credentials\" }, { status: 500 })\r\n    }\r\n\r\n    return NextResponse.json({ success: true })\r\n  } catch (err: any) {\r\n    console.error(\"Integrations POST error:\", err)\r\n    return NextResponse.json({ error: err.message ?? \"Unexpected error\" }, { status: 500 })\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}